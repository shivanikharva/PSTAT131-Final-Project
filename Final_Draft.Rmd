---
title: "Predicting the Capture Rate of Pokemon"
subtitle: "PSTAT 131 Final Project"
author: "Shivani Kharva"
date: "2022-12-06"
output:
  html_document:
    code_folding: hide
    toc: true
---

## Introduction

The purpose of this project is to develop a model that will predict the capture rate of a Pokemon.

### What Are Pokemon?

Pokemon (or "pocket monsters") are creatures from the Japanese Nintendo video game, Pokemon. Pokemon is a role-playing game in which players play as trainers who capture the Pokemon using Poke Balls and train them to compete in battles with other trainers. As they train and gain more experience through battle, Pokemon evolve and grow stronger. There are over 800 Pokemon with 18 types (i.e. fire, water, etc,), and they have numerous abilities (both common and unique).

### What Are We Trying to Do?

However, a question I'd like to pose is "How hard is to capture a Pokemon in the first place depending on their existing statistics?" It seems quite reasonable to hypothesize that a Pokemon's capture rate would vary depending on variables like their type, base statistics, generation, etc. So, I would like to test if it is possible to develop a model that can predict the capture rate of a Pokemon based on those qualities.

### Why?

Players, including me, are often only able to see the aforementioned qualities of a Pokemon and not their actual capture rate. So, it may be useful to have a specific model that can accurately predict the capture rate of a Pokemon so a player may see how difficult it may be to capture that Pokemon. The player can then adjust their strategy if a Pokemon is harder to catch by using more advanced equipment, such as using an Ultra Ball instead of a Poke Ball or giving the Pokemon a fruit before attempting to capture them to slightly lower their guard. So, let's see if the variation in the capture rate of a specific Pokemon can be explained by these qualities!

## Loading Packages and Data

```{r, message = FALSE, warning = FALSE}
# Loading all necessary packages
library(tidyverse)
library(dplyr)
library(tidymodels)
library(readr)
library(kknn)
library(janitor)
library(ISLR)
library(discrim)
library(poissonreg)
library(glmnet)
library(corrr)
library(corrplot)
library(randomForest)
library(xgboost)
library(rpart.plot)
library(vip)
library(ranger)

# Assigning the data to a variable
pokemon <- read_csv("data/pokemon.csv")
tidymodels_prefer()
set.seed(0124)

# Calling head() to see the first few rows
head(pokemon)
```


This data was taken from the Kaggle data set, "[Pokemon Stats Dataset](https://www.kaggle.com/datasets/hasanarcas/pokemon-stats-dataset)," and it was scraped from the [official Pokemon database](https://pokemondb.net/pokedex/all) by user Hasan Arcas.

## Exploring and Cleaning the Raw Data

Let's mess around with the data a little bit to see what we're currently working with!  

```{r}
# Calling dim() to see how many rows and columns
dim(pokemon)
```

The data set contains 801 rows and 41 columns. This means we have 801 Pokemon and 41 variables. One of those variables, `capture_rate`, is our response, but that leaves us with 40 predictor variables! We're definitely going to have to narrow that down!

From the data, each of the variables that specify each Pokemon's skill against a certain type of Pokemon (i.e. `against_bug`, `against_dark`, etc.) do not appear to be as relevant as other attributes in deciding whether specifc features about a Pokemon affect its capture rate. We can also assume that the `attack` variable gives us an overall estimate of each Pokemon's attack skill so we would not need to go into such great detail as finding out how the Pokemon perform against every other type of Pokemon. For that reason, these 18 columns can be dropped.

At first, it seems that the `classification` variable may be helpful; however, let us see how many unique classifications of a Pokemon there are.

```{r}
pokemon %>%
  distinct(classfication) %>%
  count()
```

There are 588 unique classifications! That seems a little too high for our analysis so we will just stick to using the `type` of the Pokemon instead.

Furthermore, for the `abilities` variable, we can see that there is no set amount for how many abilities a Pokemon has or a measure to figure out which abilities are more powerful than others. For these reasons, it may be best to avoid including this column into our analysis.

The `base_egg_steps` variable is a variable not used in the original Pokemon games so, to keep the data consistent with the game it was taken from, this variable should also be omitted.

Finally, `pokedex_number` and `japanese_name` are unique to each Pokemon and are mainly used to identify the Pokemon; however, since we already have the `name` variable, it would not be useful to include these variables.

Now, let's filter out all those unwanted variables!!

```{r}
# Selecting only the variables we want
pokemon <- pokemon %>% 
  select(c("abilities", "attack", "base_happiness",  "base_total", "capture_rate", "defense", "experience_growth", "height_m", "percentage_male", "hp", "name", "sp_attack", "sp_defense", "speed", "type1", "weight_kg", "generation", "is_legendary")) %>% 
  clean_names()
head(pokemon)
```

Upon further inspection, we can see that our outcome, `capture_rate`, is actually a character variable, which is not what we want. By looking into the values, we see that one of the Pokemon, Minior, actually has two capture rates.  

```{r}
# Finding which Pokemon has a character capture rate
filter(pokemon, capture_rate %in% c("30 (Meteorite)255 (Core)"))
```

By looking at [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Minior_(Pok%C3%A9mon)), a community Pokemon encyclopedia, we can see that Minior has a relatively low capture rate at 30 when it is "Meteorite," meaning its shell has not been broken. However, once Minior's shell is broken ("Core"), the Pokemon shoots up to a capture rate of 255, which is the highest capture rate there is. Therefore, it would make sense to keep the capture rate of Minior when it is still Meteorite.   

```{r}
# Changing Minior to capture rate 30
pokemon[pokemon$name=="Minior", "capture_rate"] <- "30"

# Making capture_rate an integer
pokemon$capture_rate <- as.integer(pokemon$capture_rate)
```

Now our outcome is an integer we can use in regression!  




### Sources
